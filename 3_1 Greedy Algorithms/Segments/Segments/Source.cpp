/*
Покрыть отрезки точками

На входе имеется некоторе колличество отрезков. Необходимо найти такое множество точек чтобы:
1) Каждый отрезок содержал в себе хотя бы одну точку из множества.
2) Колличество точек во множестве было минимальным.
П.С. Это значит что ты вначале выводишь количество точек во множестве, а затем через пробел выводишь сами точки из множества.

В первой строке дано число 1≤n≤100 отрезков. Каждая из последующих nn строк содержит по два числа 0≤L≤R≤10^9, задающих начало и конец отрезка. Выведите оптимальное число m точек и сами m точек. Если таких множеств точек несколько, выведите любое из них.

Тестовые значения:
Sample Input 1:
3
1 3
2 5
3 6
Sample Output 1:
1
3

Sample Input 2:
4
4 7
1 3
2 5
5 6
Sample Output 2:
2
3 6
*/

#include <stdio.h>
#include <iostream>
#include <corecrt_malloc.h>
#include <locale.h>

using namespace std;

void bubbleSort(int**, int);

int main(void) {
	setlocale(LC_ALL, "ru");

	int n; //количество отрезков 
	int i, j, k; //счетчики
	int **segments; //указатель на двумерный(**) динамический массив отрезков

	//Задается количество пар значений (количество отрезков = дрина динамического массива)
	cout << "Укажите количество отрезков: ";
	cin >> n;

	//Создается и заполняется массив из отрезков (длина = n, высота = 2)
	segments = new int*[n]; //количество строк массива = n
	for (i = 0; i < n; i++) {
		segments[i] = new int[2]; //количество столбцов = 2 (две точки, начало и конец отрезка)
		//заколнение массива
		for (j = 0; j < 2; j++) {
			cout << "отрезок " << i << " точка " << j << ": ";
			cin >> segments[i][j];
		}
	}

	//Сортировка отрезков (массива) по правому концу (j = 1)
	//методом пузырька (алгоритм медленный и неэффективный, но простой, сейчас подходит)
	bubbleSort(segments, n);

	//Взаимное пересечение отрезков
	//сравниваем отрезок N с отрезком N+1, то есть верхний с тем, который идет сразу за ним
	k = 1;
	while (k != 0)
	{
		k = 0; //устанавливаем счетчик пересечений на 0

		for (i = (n - 1); i >= 0; i--) { //идем с конца

			//для всех отрезков кроме первого, так как его не с чем сравнивать (иначе [i-1] выйдет за границы массива)
			if (i != 0 && segments[i][0] != 0) {
				//"склеиваем" отрезки, если они пересекаются хотя бы концами
				//то есть если конечная координата первого отрезка равна или больше начальной второго
				//массив отсортирован по конечным точкам, так что конец второго отрезка точно не меньше конца первого
				if (segments[i - 1][1] >= segments[i][0]) {
					k++; //увеличиваем счетчик пересечений
					
					//если условие выполнено, то отрезки точно пересекаются
					//сравниваем нижний и тот, который над ним
					//записываем на место верхнего новый, результат "склеивания"
					//нижний оставляем неизменным для сравнения со следующим за ним
					if (segments[i - 1][0] < segments[i][0])  { segments[i - 1][0] = segments[i][0]; }
					if (segments[i - 1][1] > segments[i][1])  { segments[i - 1][1] = segments[i][1]; }
					if (segments[i - 1][1] == segments[i][0]) { segments[i - 1][0] = segments[i][0]; }

					//на место нижнего записываем нули
					segments[i][0] = 0;
					segments[i][1] = 0;
				} 
			}
		}
		bubbleSort(segments, n);

	}

	k = 0;
	for (i = 0; i < n; i++) {
		if (segments[i][1] != 0) { k++; }
	}
	
	cout << "Количество точек: " << k << "\n";
	for (i = 0; i < n; i++) {
		if (segments[i][1] != 0) {
			cout << segments[i][1] << "  \n";
		}
	}

	system("pause");
	return 0;
}

void bubbleSort(int **array, int size) {
	int tmp_0, tmp_1; //временные переменные
	int k, m; //счетчики проходов по массиву

	for (k = 0; k < (size - 1); k++) { //k - номер прохода
		for (m = 0; m < (size - 1); m++) { //внутренний цикл прохода
			if (array[m + 1][1] < array[m][1]) {
				tmp_1 = array[m + 1][1];
				tmp_0 = array[m + 1][0];

				array[m + 1][1] = array[m][1];
				array[m + 1][0] = array[m][0];

				array[m][1] = tmp_1;
				array[m][0] = tmp_0;
			}
		}
	}
}
